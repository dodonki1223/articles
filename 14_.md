# データベースの結合アルゴリズムについてのまとめ

よく忘れてしまうので自分でまとめることによってちゃんと覚えるようにする  
本の内容と Microsoft Docs の内容を元にまとめることとする

# 概要

データベース内部ではテーブル同士の結合がされる時、主に以下の３つのうちどれかの結合アルゴリズムが使用される

- Nested Loops Join
- Hash Join
- Sort Merge Join

**注意**

使用する結合アルゴリズムを明示的に指定することもできるが、データ量や構造が変わった時に使用されるべき結合アルゴリズムは変わってくるため基本的にオプティマイザに任せた方が無難だと思われる

# 結合アルゴリズムのメリット・デメリット

それぞれの結合アルゴリズムのメリット・デメリットをざっくりとまとめる

| 結合アルゴリズム  | メリット                                                                                                             | デメリット 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　    |
|:-----------------:|:---------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------|
| Nested Loops Join | ・小さな外部表＋インデックスが効く内部表の条件下では高速<br>・メモリをあまり使用しない<br>・非等値結合にも使用できる | ・大規模テーブル同士の結合には不向き<br>・内部表にインデックスが効かない、内部表が大量に選択される場合は遅い |
| Hash Join         | ・大規模テーブル同士の結合に良い                                                                                     | ・メモリを多く使用する<br>・等値結合のみでしか使用できない                                                   |
| Sort Merge Join   | ・大規模テーブル同士の結合に良い<br>・非等値結合にも使用できる                                                       | ・メモリを多く使用する<br>・ソート済みのデータで無いと効率的ではない                                         |

# テーブルのデータ量に応じた指標

テーブルのデータ量に応じて何を使用すべきかのざっくりとした指標をまとめる

| 組み合わせ |  考慮事項                                                                                                                                                                                                |
|:----------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 小 x 小    | ・どのアルゴリズムでも大差はない                                                                                                                                                                         |
| 小 x 大    | ・小テーブルを外部表としてNested Loopを使用する（ただし大テーブル（内部表）の結合キーにインデックスが貼られていること）<br>・選択される内部表が多い場合は外部表と内部表をひっくり返すか Hash Join を検討 |
| 大 x 大    | ・Hash Join を使用する<br>・ただし結合キーがソート済みの場合はSort Merge Join を使用する                                                                                                                 |

# Nested Loops Join

言葉の通り、ネストされたループ（２重ループ）を行うアルゴリズムになります  
**外部表の１行ごと**に**内部表を１行ずつ**見に行き、合致したものを返却する動作になります

![nested_loop_join_01](https://raw.githubusercontent.com/dodonki1223/image_garage/master/qiita/14/nested_loop_join/01.png)

## 特徴

- 外部表と内部表の行数に応じて実行時間が変わってくる
- **Hash Join** や **Sort Merge Join** に比べてメモリをあまり使わない（１つ１つの処理がそこまで重くないため）

## アクセスされる行数について

基本的には二重ループなので **外部表の行数 x 内部表の行数** になります  

ただし内部表の結合キーにインデックスがある場合は内部表の走査が短縮されます。インデックスにより行が１行に特定できる場合は **外部表の行数 x 2** になります

![nested_loop_join_02](https://raw.githubusercontent.com/dodonki1223/image_garage/master/qiita/14/nested_loop_join/02.png)

アクセスされる行数が実行時間に比例するので動作を速くしたい場合はインデックスを使用するべきでしょう

## パフォーマンス・チューニング

Nested Loops Join を使用している場合でパフォーマンスを上げるには下記を意識すると良い

- **外部表を小さく**（そもそものループが小さくなるように）
- **内部表を大きく**（ただし結合キーにはインデックスが貼られていること）

ただし、検索条件なんかにより **内部表の行数が多くなる場合** はあえて、**外部表と内部表を入れ替える** ことも選択肢に入れると良い

## Microsoft Docs より

SQL Server のドキュメントの「[入れ子になっているループ結合について](https://docs.microsoft.com/ja-jp/sql/relational-databases/performance/joins?view=sql-server-ver15#understanding-nested-loops-joins)」の項目には以下のように書かれています（一部を抜粋）

- **一方の結合入力が少なく** (たとえば 10 行未満)、他方の**結合入力が多く**、その**結合列にインデックスが設定されている**場合、インデックスの入れ子になったループが**最も高速な結合演算です**
- 外部入力が少なく、内部入力があらかじめインデックスを持ち、その数が多い場合に、入れ子になっているループ結合は効果的です
- 少数の行にだけ影響を与えるトランザクションなど、**多くの小規模なトランザクションでは**、インデックス入れ子化ループ結合は **マージ結合およびハッシュ結合より優れています**
- **大規模なクエリでは**、多くの場合入れ子になっているループ結合は **最適ではありません**

## その他

- MySQLの結合アルゴリズムはこの **Nested Loops Join** しかありません
- 動画でわかりやすく動作の説明をされています
    - [The Importance of Nested Loops Joins in SQL](https://www.youtube.com/watch?v=0arjvMJihJo)

# Hash Join

結合対象のテーブルのうち **小さいテーブル（メモリ上に作成されるため小さいテーブルの方が効率がよい）をスキャン** し結合キーに対してのハッシュ値を生成した **ハッシュテーブルをメモリ上** に作成します

![hash_join_01](https://raw.githubusercontent.com/dodonki1223/image_garage/master/qiita/14/hash_join/01.png)

**大きいテーブル** に対して、 **ハッシュテーブルの結合キーのハッシュ値が存在するか調べマッチしたもの** で結合を行う

![hash_join_02](https://raw.githubusercontent.com/dodonki1223/image_garage/master/qiita/14/hash_join/02.png)

## 特徴

- メモリ上にハッシュテーブルを作成するため、Nested Loops Join に比べて**メモリを多く使用する**
- ハッシュテーブルの容量が**メモリの上限を越えるとストレージを使用する**ため、**速度が遅くなる**
- ハッシュ値に順番の概念がないため等値結合（ `=` での結合）でしか使用できない

## Nested Loops Join ではなく Hash Join を使用するケース

Nested Loops Join が **効率的に動作しない時は Hash Join を使用する** とよい

- Nested Loops Join で**適切な外部表が存在しない時**（外部表が小さいテーブルでない時）
- Nested Loops Join で使用する**内部表で走査される行数が多い時**
- Nested Loops Join で使用する内部表に**インデックスが存在しない**もしくは**インデックスを追加することができない時**

## Microsoft Docs より

SQL Server のドキュメントの「[ハッシュ結合について](https://docs.microsoft.com/ja-jp/sql/relational-databases/performance/joins?view=sql-server-ver15#understanding-hash-joins)」の項目には以下のように書かれています（一部を抜粋）

- ハッシュ結合は、**並べ替えられておらず、インデックスが設定されていない**大量の入力を効率的に処理できます
- ハッシュ結合は、**複雑なクエリでの中間結果を得るのに役立ちます**
    - 中間結果にはインデックスが設定されず (ディスクに明示的に保存した後インデックスを設定しない限り)、多くの場合、クエリ プランでの次の演算に合わせて並べ替えられることがありません
    - クエリ オプティマイザーは、中間結果のサイズだけを予想します。 複雑なクエリではこの予想が非常に不正確になる場合があります。そのため、中間結果を処理するアルゴリズムは効率的なだけでなく、中間結果が予想をはるかに上回る場合でも、パフォーマンスをあまり低下させないようにする必要があります

## その他

- **夜間バッチ**（同時並走する処理の少ない）、[BI／DWH](https://it-trend.jp/bi/article/bi_dwh) のような**スループットの低いシステム**で使用すると良い
    - ハッシュテーブルの作成でメモリを多く使用するため
- **実行時間の考慮**が必要（性質上、両方のテーブルでフルスキャンが実行されるため）
- 動画でわかりやすく動作の説明をされています
    - [Hash Match Join Internals in SQL Server](https://www.youtube.com/watch?v=59C8c7p_hII)

# Sort Merge Join

両方のテーブルを **結合キーでソート** する

![sort_merge_join_01](https://raw.githubusercontent.com/dodonki1223/image_garage/master/qiita/14/sort_merge_join/01.png)

**ソート後のテーブルを使用** して一致する結合キーがあったら結果セットに含める

![sort_merge_join_02](https://raw.githubusercontent.com/dodonki1223/image_garage/master/qiita/14/sort_merge_join/02.png)

## 特徴

- 両方の**テーブルをソートする**ため、Nested Loops Join よりも**多くのメモリを使用する**
- Hash Join と違って 等値結合（ `=` での結合）だけでなく **不等号（ `<`, `>`, `<=>`, `>=` ）を使った結合にも使用できる**。ただし否定（ `<>` ）を使った結合は使用できない
- テーブルが**結合キーでソート済み**になっていれば**ソートをスキップ**することができる
- 両方のテーブルをフルスキャンする必要がなく、ソートしているため片方のテーブルだけフルスキャンできていれば結合が終了できる

## Nested Loops Join、Hash Join ではなく Sort Merge Join を使用するケース

- テーブルの**ソートに時間がかかる**ため、**ソートをスキップできる時**に使用するとよい
- **ソートをスキップできない**場合は **Nested Loops Join と Hash Join の方を使用した**ほうがよい

## Microsoft Docs より

SQL Server のドキュメントの「[マージ結合について](https://docs.microsoft.com/ja-jp/sql/relational-databases/performance/joins?view=sql-server-ver15#understanding-merge-joins)」の項目には以下のように書かれています（一部を抜粋）

- 2 つの結合入力が少なくない場合でも、結合列に基づいて並べ替えられている場合 (並べ替えられたインデックスのスキャンにより取得された場合など)、マージ結合が最も高速な結合演算です
- 両方の結合入力が多く、2 つの入力が同じようなサイズの場合、 **あらかじめ並べ替えられたマージ結合とハッシュ結合は同じようなパフォーマンスになります**。 ただし、2 つの入力サイズが大きく異なる場合、ハッシュ結合演算の方がはるかに高速になることが多くなります。
- マージ結合自体は非常に高速ですが、 **並べ替え操作が必要な場合、時間がかかることがあります**
- データ量が多く、必要なデータを **既存の B ツリー インデックスからあらかじめ並べ替えられた形で取得できる場合** 、多くの場合、利用可能な結合アルゴリズムの中で **マージ結合が最も高速** になります

## その他

- 動画でわかりやすく動作の説明をされています
    - [Merge Join Internals in SQL Server](https://www.youtube.com/watch?v=IFUB8iw46RI)
